source file-patterns.sh

echo "::set-output name=has_outputs::false"

mapfile -d ',' -t detected_files < <(printf '%s,' "$FILES_ADDED_MODIFIED")
mapfile -d ',' -t renamed_files < <(printf '%s,' "$FILES_RENAMED")
detected_files+=(${renamed_files[@]})
echo "detected_files: ${detected_files[@]}"

mapfile -t paths_to_exclude < <(printf '%s\r\n' "$PATHS_TO_EXCLUDE_IN")

excluded_files=( $(get_files_matching_glob_pattern "$paths_to_exclude" ) )
echo "Excluded files: ${excludes_files[@]}"

function is_excluded_file {
    path_to_test=$(readlink -f $1)
    if [[ " ${excluded_files[*]} " =~ " ${path_to_test} " ]]
    then
        return 0
    else
        return 1
    fi
}

processed_files=()
for file in "${detected_files[@]}"; do
    echo $'\n'
    echo "Detected file: ${file}"
    echo "======================"
    
    # If the file is already processed, it will be ignored.
    if [[ " ${processed_files[@]} " =~ " ${file} " ]]; then
        echo "File is already processed, hence ignoring it."
        continue
    elif is_excluded_file "$file"
    then
        echo "File is to be excluded, ignoring it."
        continue
    fi

    root_file=false  
    file_path="${file%/*}"
    # When the file is at the root, the above returns file name. We need to make sure the file_path is set to '' when this is the case.
    if [[ $file_path == $file ]]; then
    root_file=true
    file_path=""
    fi
    file_without_extension="${file%.*}"
    file_name="${file_without_extension##*/}"
    file_extension="${file##*.}"
    
    # Detecting the top folder from the file path. E.g. csv/ is the top folder when the path is csv/sub-folder/my-data.csv
    if [[ $root_file == true ]]; then
    top_folder=""
    else
    top_folder=$(echo "$file_path" | cut -d "/" -f1)
    fi

    echo "---Extracting File Info"
    echo "file_path: ${file_path}"
    echo "file_without_extension: ${file_without_extension}"
    echo "file_name: ${file_name}"
    echo "file_extension: ${file_extension}"
    echo "top_folder: ${top_folder}"

    # The out/ folder is used for storing the outputs generated by csvcubed build and inspect commands. Hence, the user should not use this folder to commit any inputs. Any inputs committed to this folder will not be procssed.
    if [[ ($file_extension == "csv" || $file_extension == "json") && $top_folder != "out" ]]; then
    echo "---Processing File: ${file}"
    csv_file=""
    config_file=""
    if [[ $file_extension == "csv" ]]; then
        csv_file=${file}
        for file_secondary in "${detected_files[@]}"; do
        potential_config_file="${file_without_extension}.json"
        if [[ -f $potential_config_file ]]; then
            config_file=$potential_config_file
        fi
        done
    elif [[ $file_extension == "json" ]]; then
        config_file=$file
        potential_csv_file="${file_without_extension}.csv"
        echo "potential_csv_file: ${potential_csv_file}"
        if [[ -f $potential_csv_file ]]; then
        csv_file=$potential_csv_file
        else
        config_file=NULL
        fi
    fi
    
    echo "csv_file for processing: ${csv_file}"
    echo "config_file for processing: ${config_file}"

    if [[ -f $csv_file ]]; then
        echo "---Producing Output Path"
        # Creating the out path to store outputs.
        if [[ $root_file == true ]]; then
        out_path="out/${file_name}/"
        else
        out_path="out/${file_path}/${file_name}/"
        fi
        echo "out_path: ${out_path}"

        echo "---Building CSV-W"
        echo "Building CSV-W"
        if [[ -f $config_file ]]; then
        echo "Config for ${csv_file} is available: ${config_file}"
        csvcubed build "$csv_file" -c "$config_file" --out "$out_path" --validation-errors-to-file
        else
        echo "Config for ${csv_file} is not available"
        csvcubed build "$csv_file" --out "$out_path" --validation-errors-to-file
        fi
        
        echo "---Inspecting CSV-W"
        mapfile -d $'\0' inspectable_files < <(find "${GITHUB_WORKSPACE}/${out_path}" -name "*.csv-metadata.json" -type f -print0)
        for inspect_file in "${inspectable_files[@]}"; do
        echo "Inspecting file: ${inspect_file}"
        inspect_file_path="${inspect_file%/*}"
        inspect_file_name="${inspect_file##*/}"                  
        inspect_output_file="${out_path}${inspect_file_name}_inspect_output.txt"

        csvcubed inspect "$inspect_file" > "$inspect_output_file"
        done
        
        processed_files+=($csv_file)
        processed_files+=($config_file)
        echo "processed_files: ${processed_files[@]}"
        
        echo "::set-output name=has_outputs::true"
        
        echo "---Finished Processing File: ${file}"
        echo "======================"                
    fi
    fi
done